# Pattern Matching

Pattern matching is extremely powerful in Elixir and you'll use it all the time. Let's see some examples:

## Against Basic Types

```elixir
# You can match against many data structures, like a map.
# This is a partial match, meaning the 'height' value gets ignored.
%{age: age, name: name} = %{age: 32, name: "Peter", height: 190.47}
IO.inspect([age, name], label: 1)

# Or a Tuple. You can't match partially though.
{a, _, c} = {1, 2, 3}
IO.inspect([a, c], label: 2)

# Or a Keyword list, but you can't match partially either.
[a: a, b: b, c: c] = [a: 1, b: 2, c: 3]
IO.inspect([a, b, c], label: 3)

# Or a list, but again, not partially.
[a, b, _] = [1, 2, 3]
IO.inspect([a, b], label: 4)

# But you can match against the head (first element) and tail (the rest) of a list.
[head | tail] = [1, 2, 3]
IO.inspect(head, label: "5 - head")
IO.inspect(tail, label: "5 - tail")
```

<!-- livebook:{"output":true} -->

```
1: [32, "Peter"]
2: [1, 3]
3: [1, 2, 3]
4: [1, 2]
5 - head: 1
5 - tail: [2, 3]
```

## In Functions

```elixir
# You can match (partially) in function clauses:
fun = fn
  %{status: status} -> status
  %{age: age} -> age
end

fun.(%{status: :active, height: 190.47}) |> IO.inspect(label: 1)
fun.(%{age: 32, height: 190.47}) |> IO.inspect(label: 2)

# Or in Module functions
defmodule RunElixir.Profile do
  def details(%{status: status}), do: status
  def details(%{age: age}), do: age
end

%{status: :inactive, height: 190.47} |> RunElixir.Profile.details() |> IO.inspect(label: 3)
%{age: 30, height: 190.47} |> RunElixir.Profile.details() |> IO.inspect(label: 4)
```

<!-- livebook:{"output":true} -->

```
1: :active
2: 32
3: :inactive
4: 30
```

## In Strings

```elixir
# You can match against the end of a string
"My name is " <> name = "My name is Batman"
IO.inspect(name, label: 1)

# Or you can match against specific bytes
#
# This is extremely useful for deconstructing a string into fixed-sized byte chunks.
# For example, to implement a communicationi protocol for which you know that
# the first 3 bytes are one argument, and the next 8 bytes are the second, and so on.
<<article::binary-size(3), _space::binary-size(1), name::binary-size(6), rest::binary>> = "The Batman is my name"
IO.inspect(article, label: "2 - article")
IO.inspect(name, label: "2 - name")
IO.inspect(rest, label: "2 - rest")
```

<!-- livebook:{"output":true} -->

```
1: "Batman"
2 - head: "Batman"
2 - rest: " is my name"
```

## The Pin Operator

The Pin `^` operator allows you to match against the value of an existing variable:

```elixir
name = "Peter"

fun = fn
  %{name: ^name} -> "That's me!"
  %{name: _name} -> "That's not me."
end

fun.(%{name: "Peter"}) |> IO.inspect(label: 1)
fun.(%{name: "Bob"}) |> IO.inspect(label: 2)
```

<!-- livebook:{"output":true} -->

```
1: "That's me!"
2: "That's not me."
```